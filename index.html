<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atomic Blast Chess</title>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <style>
        :root { --bg: #0b0c15; --accent: #00f3ff; --danger: #ff0055; --valid: #00ff88; }
        body { margin: 0; background: var(--bg); color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; touch-action: none; }
        
        #game-ui { width: 95vmin; height: 95vmin; max-width: 600px; max-height: 600px; position: relative; display: flex; flex-direction: column; gap: 10px; }
        
        .header { display: flex; justify-content: space-between; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; }
        h1 { margin: 0; font-size: 1.1rem; color: var(--accent); }
        #status { font-weight: bold; color: #aaa; }
        
        #board-wrapper { flex: 1; position: relative; border: 2px solid #333; background: #1e1e24; transition: transform 0.5s; }
        .rotated { transform: rotate(180deg); }
        
        #board-grid { 
            width: 100%; height: 100%; 
            display: grid; 
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr); 
        }
        
        .square { width: 100%; height: 100%; position: relative; z-index: 5; }
        .light { background: #2d2d3a; } .dark { background: #1e1e24; }
        
        .selected-sq { background: rgba(0, 243, 255, 0.4) !important; }
        
        /* Check warning is now just visual info, not a blocker */
        .in-check { background: radial-gradient(circle, rgba(255, 0, 85, 0.8) 0%, transparent 80%) !important; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        .valid-move::after { 
            content:''; position: absolute; width: 25%; height: 25%; 
            background: var(--valid); border-radius: 50%; 
            top: 37.5%; left: 37.5%; box-shadow: 0 0 8px var(--valid); 
            z-index: 8; pointer-events: none;
        }
        .capture-move { background: rgba(255, 0, 85, 0.4) !important; box-shadow: inset 0 0 15px var(--danger); }
        
        .layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #pieces { z-index: 10; }
        #effects { z-index: 20; }

        .piece { position: absolute; width: 12.5%; height: 12.5%; display: flex; justify-content: center; align-items: center; font-size: 8vmin; transition: transform 0.2s; z-index: 15; }
        @media(min-width:600px) { .piece { font-size: 3rem; } }
        .p-w { color: #fff; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5)); }
        .p-b { color: #111; text-shadow: 0 0 2px rgba(255,255,255,0.5); }

        .explosion { position: absolute; width: 12.5%; height: 12.5%; border-radius: 50%; background: radial-gradient(circle, #fff 0%, #f00 100%); animation: boom 0.6s forwards; mix-blend-mode: screen; z-index: 50; }
        @keyframes boom { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(3); opacity: 0; } }
        .shake { animation: shake 0.4s; }
        @keyframes shake { 0%,100% { transform: translate(0,0) rotate(var(--rot)); } 25% { transform: translate(5px,0) rotate(var(--rot)); } 75% { transform: translate(-5px,0) rotate(var(--rot)); } }

        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(11,12,21,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .hidden { display: none !important; }
        
        button { background: transparent; border: 1px solid #fff; color: #fff; padding: 12px 24px; margin: 8px; cursor: pointer; text-transform: uppercase; width: 220px; font-weight: bold; }
        button:hover { background: var(--accent); color: #000; border-color: var(--accent); }
        .primary { border-color: var(--accent); color: var(--accent); }
        .footer { display: flex; justify-content: center; gap: 10px; }
        .footer button { width: auto; font-size: 0.8rem; padding: 8px 16px; width: auto; }
        
        #win-modal { background: rgba(0,0,0,0.9); z-index: 200; }
        #win-text { font-size: 2rem; color: var(--valid); margin-bottom: 20px; text-align: center; }
    </style>
</head>
<body>

    <div id="menu" class="overlay">
        <h1 style="color:var(--accent); font-size:3rem; margin-bottom:20px;">ATOMIC<br>CHESS</h1>
        <button class="primary" onclick="Game.findMatch()">Play Online</button>
        <button onclick="Game.startLocal()">Local PvP</button>
        <button onclick="Game.startBot()">Vs Smart Bot</button>
        <div style="margin-top:20px; color:#555; font-size:0.8rem;">Capture The King Edition</div>
    </div>

    <div id="loading" class="overlay hidden">
        <div style="font-size:1.5rem; margin-bottom:20px;">Searching...</div>
        <button onclick="Game.cancelMatch()">Cancel</button>
    </div>

    <div id="win-modal" class="overlay hidden">
        <div id="win-text">WHITE WINS!</div>
        <button class="primary" onclick="location.reload()">Menu</button>
    </div>

    <div id="game-ui">
        <div class="header">
            <h1 id="app-title">Atomic Chess</h1>
            <span id="status">Ready</span>
        </div>
        <div id="board-wrapper">
            <div id="board-grid"></div>
            <div id="pieces" class="layer"></div>
            <div id="effects" class="layer"></div>
        </div>
        <div class="footer">
            <button onclick="document.getElementById('menu').classList.remove('hidden')">Menu</button>
            <button onclick="Game.undo()">Undo</button>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyCLB5bIoXGPWpfGkewBcXOJGBczK6c3L54",
            authDomain: "explosive-checkmate.firebaseapp.com",
            projectId: "explosive-checkmate",
            storageBucket: "explosive-checkmate.firebasestorage.app",
            messagingSenderId: "731999225742",
            appId: "1:731999225742:web:349d39589df0558f4d06df",
            measurementId: "G-X50W31QC4R"
        };

        function nr(r, c) { return r>=0 && r<8 && c>=0 && c<8; }

        const Engine = {
            board: [], turn: 'w',
            
            init() {
                this.board = [
                    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
                    ['bP','bP','bP','bP','bP','bP','bP','bP'],
                    ...Array(4).fill(null).map(()=>Array(8).fill(null)),
                    ['wP','wP','wP','wP','wP','wP','wP','wP'],
                    ['wR','wN','wB','wQ','wK','wB','wN','wR']
                ];
                this.turn = 'w';
            },

            applyMove(boardState, from, to) {
                const newBoard = JSON.parse(JSON.stringify(boardState));
                const p = newBoard[from.r][from.c];
                const t = newBoard[to.r][to.c];
                const exploded = [];

                newBoard[to.r][to.c] = p;
                newBoard[from.r][from.c] = null;

                if(p && p[1]==='P' && (to.r===0 || to.r===7)) {
                    newBoard[to.r][to.c] = p[0]+'Q';
                }

                if (t) { 
                    for(let i=to.r-1; i<=to.r+1; i++) {
                        for(let j=to.c-1; j<=to.c+1; j++) {
                            if(nr(i,j)) {
                                // Attacker survives rule
                                if (i === to.r && j === to.c) continue;

                                const victim = newBoard[i][j];
                                if (victim) {
                                    if (victim[1] !== 'K') {
                                        newBoard[i][j] = null;
                                    }
                                }
                                exploded.push({r:i, c:j});
                            }
                        }
                    }
                }
                return { board: newBoard, exploded, captured: !!t };
            },

            getLegalMoves(r, c, currentBoard = this.board) {
                const p = currentBoard[r][c];
                if(!p) return [];
                const pseudo = this.getPseudoMoves(r, c, currentBoard);
                const myColor = p[0];

                return pseudo.filter(move => {
                    const res = this.applyMove(currentBoard, {r,c}, move);
                    const enemyColor = myColor==='w'?'b':'w';
                    
                    // === RULES UPDATE ===
                    // You can move into check. You can expose your king.
                    // The only rule is: you cannot suicide your king (blow it up yourself).
                    // But since Kings are immune to splash damage in this version, 
                    // they can only die by direct capture.
                    // So basically: ALL pseudo moves are legal unless we somehow delete our own king directly (impossible).
                    
                    if (!this.findKing(res.board, myColor)) return false; // Just in case

                    return true;
                });
            },

            getPseudoMoves(r, c, boardState) {
                const p = boardState[r][c];
                if (!p) return [];
                const color = p[0];
                const type = p[1];
                const moves = [];

                const add = (nr, nc) => {
                    if (nr>=0 && nr<8 && nc>=0 && nc<8) {
                        const target = boardState[nr][nc];
                        if (target === null) {
                            moves.push({r:nr, c:nc});
                            return true;
                        } else if (target[0] !== color) {
                            moves.push({r:nr, c:nc});
                            return false;
                        }
                    }
                    return false;
                };

                const dirs = {
                    R: [[0,1],[0,-1],[1,0],[-1,0]],
                    B: [[1,1],[1,-1],[-1,1],[-1,-1]],
                    N: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
                    K: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
                };
                dirs.Q = [...dirs.R, ...dirs.B];

                if (type === 'P') {
                    const d = color === 'w' ? -1 : 1;
                    if (nr(r+d, c) && boardState[r+d][c] === null) {
                        moves.push({r:r+d, c});
                        if ((color==='w'&&r===6 || color==='b'&&r===1) && boardState[r+d*2][c] === null) {
                            moves.push({r:r+d*2, c});
                        }
                    }
                    [[d,1],[d,-1]].forEach(([dr,dc]) => {
                        if (nr(r+dr, c+dc)) {
                            const t = boardState[r+dr][c+dc];
                            if (t && t[0]!==color) moves.push({r:r+dr, c:c+dc});
                        }
                    });
                } else if (['R','B','Q'].includes(type)) {
                    dirs[type].forEach(([dr, dc]) => {
                        let nr = r+dr, nc = c+dc;
                        while(add(nr, nc)) { nr+=dr; nc+=dc; }
                    });
                } else {
                    dirs[type].forEach(([dr, dc]) => add(r+dr, c+dc));
                }
                return moves;
            },

            findKing(board, color) {
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    if(board[r][c] === color+'K') return {r,c};
                }
                return null;
            },

            isKingInCheck(boardState, color) {
                const kPos = this.findKing(boardState, color);
                if (!kPos) return true;
                const enemyColor = color==='w'?'b':'w';
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    const p = boardState[r][c];
                    if(p && p[0]===enemyColor) {
                        const moves = this.getPseudoMoves(r, c, boardState);
                        if(moves.some(m => m.r===kPos.r && m.c===kPos.c)) return true;
                    }
                }
                return false;
            },

            checkState() {
                const wKing = this.findKing(this.board, 'w');
                const bKing = this.findKing(this.board, 'b');
                if (!wKing) return 'b'; 
                if (!bKing) return 'w'; 
                
                // Stalemate logic
                let hasMove = false;
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        const p = this.board[r][c];
                        if (p && p[0] === this.turn) {
                            if (this.getLegalMoves(r, c).length > 0) {
                                hasMove = true;
                                break;
                            }
                        }
                    }
                    if(hasMove) break;
                }
                if (!hasMove) return 'draw';

                return null;
            }
        };

        const Game = {
            selected: null, validMoves: [], history: [],
            mode: 'local', myColor: 'w', gameId: null, user: null, isOver: false,

            init() {
                Engine.init();
                this.setupGrid();
                try {
                    firebase.initializeApp(firebaseConfig);
                    this.db = firebase.firestore();
                    firebase.auth().onAuthStateChanged(u => {
                        this.user = u;
                        if(!u) firebase.auth().signInAnonymously();
                    });
                } catch(e) {}
                this.render();
            },

            setupGrid() {
                const g = document.getElementById('board-grid');
                g.innerHTML = '';
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    const d = document.createElement('div');
                    d.className = `square ${(r+c)%2===0?'light':'dark'}`;
                    d.dataset.r = r; d.dataset.c = c;
                    d.onclick = () => this.handleClick(r, c);
                    g.appendChild(d);
                }
            },

            handleClick(r, c) {
                if (this.isOver) return;
                if (this.mode === 'online' && Engine.turn !== this.myColor) return;

                if (this.selected) {
                    const move = this.validMoves.find(m => m.r === r && m.c === c);
                    if (move) {
                        this.executeMove(this.selected, move);
                        this.clearSelection();
                        return;
                    }
                }

                const p = Engine.board[r][c];
                if (p && p[0] === Engine.turn) {
                    this.selected = {r, c};
                    this.validMoves = Engine.getLegalMoves(r, c);
                    this.highlightMoves();
                } else {
                    this.clearSelection();
                }
            },

            highlightMoves() {
                this.clearHighlights();
                const g = document.getElementById('board-grid').children;
                const selIdx = this.selected.r*8 + this.selected.c;
                g[selIdx].classList.add('selected-sq');

                this.validMoves.forEach(m => {
                    const idx = m.r*8 + m.c;
                    if (Engine.board[m.r][m.c]) g[idx].classList.add('capture-move');
                    else g[idx].classList.add('valid-move');
                });
            },

            clearHighlights() {
                document.querySelectorAll('.square').forEach(el => 
                    el.className = el.className.replace(/ selected-sq| valid-move| capture-move/g, '')
                );
            },

            clearSelection() {
                this.selected = null;
                this.validMoves = [];
                this.clearHighlights();
            },

            executeMove(from, to, isRemote = false) {
                if(!isRemote) this.history.push({b: JSON.stringify(Engine.board), t: Engine.turn});

                const res = Engine.applyMove(Engine.board, from, to);
                Engine.board = res.board;

                if(res.exploded.length > 0) this.showExplosion(res.exploded);

                const winner = Engine.checkState();
                if (winner && winner !== 'draw') {
                    this.handleWin(winner);
                    if(this.mode === 'online' && !isRemote) {
                        this.db.collection('atomic_games').doc(this.gameId).update({
                            board: JSON.stringify(Engine.board),
                            winner: winner
                        });
                    }
                    return;
                }

                const nextTurn = Engine.turn === 'w' ? 'b' : 'w';
                Engine.turn = nextTurn;

                if(this.mode === 'online' && !isRemote) {
                    this.db.collection('atomic_games').doc(this.gameId).update({
                        board: JSON.stringify(Engine.board),
                        turn: nextTurn,
                        lastMove: {from, to, exploded: res.exploded}
                    });
                } else {
                    this.render();
                    if(this.mode === 'bot' && nextTurn === 'b') setTimeout(() => this.botThink(), 500);
                }
                this.render();
            },

            handleWin(result) {
                this.isOver = true;
                this.render();
                const texts = { 'w': "WHITE WINS!", 'b': "BLACK WINS!", 'draw': "DRAW" };
                const color = result === 'w' ? "#fff" : (result==='draw' ? '#aaa' : "var(--accent)");
                
                document.getElementById('win-text').innerText = texts[result];
                document.getElementById('win-text').style.color = color;
                document.getElementById('win-modal').classList.remove('hidden');
            },

            botThink() {
                const moves = [];
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    if(Engine.board[r][c]?.startsWith('b')) {
                        Engine.getLegalMoves(r, c).forEach(to => moves.push({from:{r,c}, to}));
                    }
                }

                if(moves.length === 0) return; 

                let bestMove = null;
                let bestScore = -Infinity;

                for (let m of moves) {
                    const score = this.evaluateMove(m);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = m;
                    } else if (score === bestScore && Math.random() > 0.5) {
                        bestMove = m;
                    }
                }
                this.executeMove(bestMove.from, bestMove.to);
            },

            evaluateMove(m) {
                const simRes = Engine.applyMove(Engine.board, m.from, m.to);
                let score = 0;

                if (m.to.r!==undefined && Engine.board[m.to.r][m.to.c]) score += 10; 
                if (!Engine.findKing(simRes.board, 'w')) score += 100000; // KILL KING
                if (!Engine.findKing(simRes.board, 'b')) score -= 100000; // SUICIDE
                
                // Bot prefers not to be in check, even if it's legal
                if (Engine.isKingInCheck(simRes.board, 'b')) score -= 200;

                score += Math.random() * 5;
                return score;
            },

            render() {
                const layer = document.getElementById('pieces');
                layer.innerHTML = '';
                const sym = {w:{K:'♔',Q:'♕',R:'♖',B:'♗',N:'♘',P:'♙'}, b:{K:'♚',Q:'♕',R:'♜',B:'♝',N:'♞',P:'♟'}};
                const rot = (this.mode==='online' && this.myColor==='b');
                
                document.getElementById('board-wrapper').style.transform = rot ? 'rotate(180deg)' : '';
                document.getElementById('board-wrapper').style.setProperty('--rot', rot ? '180deg' : '0deg');

                // Clear Check Highlights
                document.querySelectorAll('.square').forEach(el => el.classList.remove('in-check'));

                // Draw Pieces
                Engine.board.forEach((row, r) => row.forEach((c, col) => {
                    if(!c) return;
                    const el = document.createElement('div');
                    el.className = `piece p-${c[0]}`;
                    el.textContent = sym[c[0]][c[1]];
                    el.style.transform = `translate(${col*100}%, ${r*100}%) ${rot?'rotate(180deg)':''}`;
                    layer.appendChild(el);

                    // Show Check
                    if (c[1] === 'K') {
                        if (Engine.isKingInCheck(Engine.board, c[0])) {
                            const idx = r*8 + col;
                            document.getElementById('board-grid').children[idx].classList.add('in-check');
                        }
                    }
                }));

                const txt = this.mode==='online' 
                    ? (Engine.turn===this.myColor ? "YOUR TURN" : "OPPONENT") 
                    : (Engine.turn==='w' ? "White Turn" : "Black Turn");
                document.getElementById('status').textContent = txt;
            },

            showExplosion(coords) {
                const layer = document.getElementById('effects');
                const wrap = document.getElementById('board-wrapper');
                wrap.classList.remove('shake');
                void wrap.offsetWidth;
                wrap.classList.add('shake');
                coords.forEach(p => {
                    const el = document.createElement('div');
                    el.className = 'explosion';
                    el.style.left = (p.c * 12.5) + '%';
                    el.style.top = (p.r * 12.5) + '%';
                    layer.appendChild(el);
                    setTimeout(() => el.remove(), 600);
                });
            },

            async findMatch() {
                document.getElementById('loading').classList.remove('hidden');
                this.mode = 'online';
                const ref = this.db.collection('atomic_games');
                const snap = await ref.where('status', '==', 'waiting').limit(1).get();
                if(!snap.empty) {
                    const doc = snap.docs[0];
                    await doc.ref.update({ status: 'playing', playerBlack: this.user.uid });
                    this.startGame(doc.id, 'b');
                } else {
                    const doc = await ref.add({ status: 'waiting', createdAt: firebase.firestore.FieldValue.serverTimestamp(), playerWhite: this.user.uid, board: JSON.stringify(Engine.board), turn: 'w' });
                    this.startGame(doc.id, 'w');
                }
            },
            startGame(id, color) {
                this.gameId = id; this.myColor = color;
                this.unsub = this.db.collection('atomic_games').doc(id).onSnapshot(doc => {
                    const d = doc.data();
                    if(!d || d.status !== 'playing') return;
                    document.getElementById('menu').classList.add('hidden');
                    document.getElementById('loading').classList.add('hidden');
                    
                    if (d.winner) {
                        this.handleWin(d.winner);
                        return;
                    }

                    if(d.board !== JSON.stringify(Engine.board)) {
                        Engine.board = JSON.parse(d.board);
                        Engine.turn = d.turn;
                        if(d.lastMove?.exploded?.length && Engine.turn === this.myColor) this.showExplosion(d.lastMove.exploded);
                        this.render();
                    }
                });
            },
            cancelMatch() {
                if(this.unsub) this.unsub();
                if(this.gameId && this.myColor==='w') this.db.collection('atomic_games').doc(this.gameId).delete();
                document.getElementById('loading').classList.add('hidden');
            },
            startLocal() { this.mode='local'; document.getElementById('menu').classList.add('hidden'); Engine.init(); this.render(); },
            startBot() { this.mode='bot'; document.getElementById('menu').classList.add('hidden'); Engine.init(); this.render(); },
            undo() {
                if(this.mode === 'online') return;
                if(this.history.length) {
                    const state = this.history.pop();
                    Engine.board = JSON.parse(state.b);
                    Engine.turn = state.t;
                    this.isOver = false;
                    document.getElementById('win-modal').classList.add('hidden');
                    if(this.mode === 'bot' && this.history.length) {
                        const s2 = this.history.pop();
                        Engine.board = JSON.parse(s2.b);
                        Engine.turn = s2.t;
                    }
                    this.render();
                    this.clearSelection();
                }
            }
        };

        Game.init();
    </script>
</body>
</html>
