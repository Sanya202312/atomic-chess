<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Atomic Blast Chess: Chaos</title>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <style>
        :root { --bg: #0b0c15; --accent: #00f3ff; --danger: #ff0055; --valid: #00ff88; --warning: #ffaa00; --bridge: #a855f7; }
        body { margin: 0; background: var(--bg); color: #fff; font-family: 'Segoe UI', Roboto, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; touch-action: none; }
        
        #game-ui { width: 95vmin; height: 95vmin; max-width: 600px; max-height: 600px; position: relative; display: flex; flex-direction: column; gap: 10px; z-index: 10; }
        
        .header { display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); }
        h1 { margin: 0; font-size: 1.1rem; color: var(--accent); letter-spacing: 1px; }
        #status { font-weight: bold; color: #aaa; font-size: 0.9rem; }
        
        #board-wrapper { flex: 1; position: relative; border: 2px solid #333; background: #1e1e24; transition: transform 0.5s; border-radius: 4px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .rotated { transform: rotate(180deg); }
        
        #board-grid { 
            width: 100%; height: 100%; 
            display: grid; 
            grid-template-columns: repeat(8, 1fr); 
            grid-template-rows: repeat(8, 1fr); 
        }
        
        .square { width: 100%; height: 100%; position: relative; z-index: 5; }
        .light { background: #2d2d3a; } .dark { background: #1e1e24; }
        
        /* The Bridge Zone */
        .bridge-zone { box-shadow: inset 0 0 10px var(--bridge); background: rgba(168, 85, 247, 0.1); }

        /* Highlights */
        .selected-sq { background: rgba(0, 243, 255, 0.4) !important; box-shadow: inset 0 0 15px rgba(0,243,255,0.5); }
        
        .in-check { background: radial-gradient(circle, rgba(255, 0, 85, 0.8) 0%, transparent 80%) !important; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        .valid-move::after { 
            content:''; position: absolute; width: 25%; height: 25%; 
            background: var(--valid); border-radius: 50%; 
            top: 37.5%; left: 37.5%; box-shadow: 0 0 8px var(--valid); 
            z-index: 8; pointer-events: none;
        }
        .capture-move { background: rgba(255, 0, 85, 0.4) !important; box-shadow: inset 0 0 15px var(--danger); }
        
        .layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #pieces { z-index: 10; }
        #effects { z-index: 20; }

        .piece { position: absolute; width: 12.5%; height: 12.5%; display: flex; justify-content: center; align-items: center; font-size: 8vmin; transition: transform 0.2s; z-index: 15; }
        @media(min-width:600px) { .piece { font-size: 3rem; } }
        .p-w { color: #fff; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5)); }
        .p-b { color: #111; text-shadow: 0 0 2px rgba(255,255,255,0.5); }

        .explosion { position: absolute; width: 12.5%; height: 12.5%; border-radius: 50%; background: radial-gradient(circle, #fff 0%, #f00 100%); animation: boom 0.6s forwards; mix-blend-mode: screen; z-index: 50; }
        @keyframes boom { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(3); opacity: 0; } }
        
        .gravity-fx { animation: fall 0.5s ease-in; }
        @keyframes fall { 0% { transform: translateY(0); } 100% { transform: translateY(100%); opacity: 0; } }

        .shake { animation: shake 0.4s; }
        @keyframes shake { 0%,100% { transform: translate(0,0) rotate(var(--rot)); } 25% { transform: translate(5px,0) rotate(var(--rot)); } 75% { transform: translate(-5px,0) rotate(var(--rot)); } }

        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(11,12,21,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; backdrop-filter: blur(5px); }
        .hidden { display: none !important; }
        
        button { background: transparent; border: 1px solid #fff; color: #fff; padding: 12px 24px; margin: 8px; cursor: pointer; text-transform: uppercase; width: 220px; font-weight: bold; border-radius: 4px; transition: 0.2s; }
        button:hover { background: var(--accent); color: #000; border-color: var(--accent); box-shadow: 0 0 15px var(--accent); }
        .primary { border-color: var(--accent); color: var(--accent); }
        
        .footer { display: flex; justify-content: center; gap: 10px; }
        .footer button { width: auto; font-size: 0.8rem; padding: 8px 16px; width: auto; }
        
        #win-modal { background: rgba(0,0,0,0.9); z-index: 200; }
        #win-text { font-size: 2rem; color: var(--valid); margin-bottom: 20px; text-align: center; text-shadow: 0 0 20px var(--valid); }

        /* Notification Toast */
        #toast { position: absolute; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); border: 1px solid var(--warning); color: var(--warning); padding: 10px 20px; border-radius: 20px; z-index: 200; opacity: 0; transition: opacity 0.5s; pointer-events: none; white-space: nowrap; }
        #toast.show { opacity: 1; }

        /* --- CHAOS RULES DRAWER --- */
        .drawer { position: fixed; top: 0; right: 0; bottom: 0; width: 320px; background: rgba(15, 16, 25, 0.98); backdrop-filter: blur(15px); border-left: 1px solid rgba(255,255,255,0.1); transform: translateX(100%); transition: transform 0.3s; z-index: 500; display: flex; flex-direction: column; padding: 20px; box-shadow: -10px 0 30px rgba(0,0,0,0.5); }
        .drawer.open { transform: translateX(0); }
        .drawer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .drawer-title { margin: 0; font-size: 1.2rem; color: var(--warning); text-transform: uppercase; letter-spacing: 1px; }
        .close-btn { width: 30px; height: 30px; padding: 0; border: none; background: transparent; color: #fff; font-size: 1.5rem; }
        .rule-list { overflow-y: auto; flex: 1; padding-right: 5px; }
        .rule-card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); padding: 12px; margin-bottom: 10px; border-radius: 6px; }
        .rule-card.active { border-color: var(--valid); background: rgba(0, 255, 136, 0.05); position: relative; }
        .rule-card.active::after { content: 'ACTIVE'; position: absolute; top: 5px; right: 5px; font-size: 0.6rem; color: var(--valid); border: 1px solid var(--valid); padding: 1px 4px; border-radius: 3px; }
        .rule-name { font-weight: bold; color: #fff; margin-bottom: 4px; font-size: 0.9rem; }
        .rule-desc { font-size: 0.75rem; color: #aaa; }
        .chaos-btn { border-color: var(--warning); color: var(--warning); font-size: 0.75rem; padding: 5px 10px; width: auto; margin: 0; }
    </style>
</head>
<body>

    <div id="menu" class="overlay">
        <h1 style="color:var(--accent); font-size:3rem; margin-bottom:20px;">ATOMIC<br>CHESS</h1>
        <button class="primary" onclick="Game.findMatch()">Play Online</button>
        <button onclick="Game.startLocal()">Local PvP</button>
        <button onclick="Game.startBot()">Vs Smart Bot</button>
        <div style="margin-top:20px; color:#555; font-size:0.8rem;">REAL CHAOS IMPLEMENTED</div>
    </div>

    <div id="loading" class="overlay hidden">
        <div style="font-size:1.5rem; margin-bottom:20px;">Searching...</div>
        <button onclick="Game.cancelMatch()">Cancel</button>
    </div>

    <div id="win-modal" class="overlay hidden">
        <div id="win-text">WHITE WINS!</div>
        <button class="primary" onclick="location.reload()">Menu</button>
    </div>

    <div id="toast">Gravity Shift!</div>

    <!-- RULES DRAWER -->
    <div id="rules-drawer" class="drawer">
        <div class="drawer-header">
            <h2 class="drawer-title">Active Rules</h2>
            <button class="close-btn" onclick="UI.toggleRules()">√ó</button>
        </div>
        <div class="rule-list">
            <div class="rule-card active"><div class="rule-name">‚ò¢Ô∏è Atomic Blast</div><div class="rule-desc">Captures trigger a 3x3 explosion. Kings are immune to splash.</div></div>
            <div class="rule-card active"><div class="rule-name">üë∫ Goblin Saboteur</div><div class="rule-desc">Pawns explode the entire back rank upon reaching it instead of promoting.</div></div>
            <div class="rule-card active"><div class="rule-name">üåâ The Bridge</div><div class="rule-desc">Only ONE unit can exist on the center 4 squares (D4,E4,D5,E5) at a time.</div></div>
            <div class="rule-card active"><div class="rule-name">üëª Quantum Pawn</div><div class="rule-desc">Pawns can move backwards 1 square.</div></div>
            <div class="rule-card active"><div class="rule-name">ü©∏ Vampire Queen</div><div class="rule-desc">Queen captures resurrect a dead Pawn.</div></div>
            <div class="rule-card active"><div class="rule-name">üå™Ô∏è Gravity</div><div class="rule-desc">Every 5 turns, all pieces slide down.</div></div>
            <div class="rule-card active"><div class="rule-name">üí£ Minefield</div><div class="rule-desc">3 hidden mines on the board. Stepping on them kills you.</div></div>
        </div>
    </div>

    <div id="game-ui">
        <div class="header">
            <h1 id="app-title">Atomic Chess</h1>
            <div style="display:flex; align-items:center; gap:10px;">
                <span id="status">Ready</span>
                <button class="chaos-btn" onclick="UI.toggleRules()">‚ö†Ô∏è CHAOS</button>
            </div>
        </div>
        <div id="board-wrapper">
            <div id="board-grid"></div>
            <div id="pieces" class="layer"></div>
            <div id="effects" class="layer"></div>
        </div>
        <div class="footer">
            <button onclick="document.getElementById('menu').classList.remove('hidden')">Menu</button>
            <button onclick="Game.undo()">Undo</button>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyCLB5bIoXGPWpfGkewBcXOJGBczK6c3L54",
            authDomain: "explosive-checkmate.firebaseapp.com",
            projectId: "explosive-checkmate",
            storageBucket: "explosive-checkmate.firebasestorage.app",
            messagingSenderId: "731999225742",
            appId: "1:731999225742:web:349d39589df0558f4d06df",
            measurementId: "G-X50W31QC4R"
        };

        function nr(r, c) { return r>=0 && r<8 && c>=0 && c<8; }

        const UI = {
            toggleRules: () => document.getElementById('rules-drawer').classList.toggle('open'),
            showToast: (msg) => {
                const t = document.getElementById('toast');
                t.innerText = msg;
                t.classList.add('show');
                setTimeout(() => t.classList.remove('show'), 2000);
            }
        };

        const Engine = {
            board: [], turn: 'w', mines: [], turnCount: 0,
            
            init() {
                this.board = [
                    ['bR','bN','bB','bQ','bK','bB','bN','bR'],
                    ['bP','bP','bP','bP','bP','bP','bP','bP'],
                    ...Array(4).fill(null).map(()=>Array(8).fill(null)),
                    ['wP','wP','wP','wP','wP','wP','wP','wP'],
                    ['wR','wN','wB','wQ','wK','wB','wN','wR']
                ];
                this.turn = 'w';
                this.turnCount = 0;
                this.generateMines();
            },

            generateMines() {
                this.mines = [];
                while(this.mines.length < 3) {
                    const r = Math.floor(Math.random()*4)+2; // 2-5 (Center-ish)
                    const c = Math.floor(Math.random()*8);
                    const k = `${r},${c}`;
                    if(!this.mines.includes(k)) this.mines.push(k);
                }
            },

            isBridgeOccupied(boardState, exceptR, exceptC) {
                // Bridge: 3,3 | 3,4 | 4,3 | 4,4
                const bridge = [[3,3],[3,4],[4,3],[4,4]];
                for(let b of bridge) {
                    if (b[0] === exceptR && b[1] === exceptC) continue; // Don't count moving piece
                    if (boardState[b[0]][b[1]]) return true;
                }
                return false;
            },

            applyMove(boardState, from, to) {
                const newBoard = JSON.parse(JSON.stringify(boardState));
                const p = newBoard[from.r][from.c];
                const t = newBoard[to.r][to.c];
                const exploded = [];
                let msg = null;

                // 1. GRAVITY CHECK (Pre-move)
                // Actually gravity should happen end of turn, but let's simulate effect.
                // We keep gravity discrete for now to avoid complexity in valid move calc.

                // 2. MINE CHECK
                if (this.mines.includes(`${to.r},${to.c}`)) {
                    newBoard[from.r][from.c] = null;
                    exploded.push(to);
                    return { board: newBoard, exploded, captured: false, msg: "BOOM! Mine!" };
                }

                // 3. MOVE
                newBoard[to.r][to.c] = p;
                newBoard[from.r][from.c] = null;

                // 4. GOBLIN SABOTEUR (Pawn @ End)
                if(p && p[1]==='P' && (to.r===0 || to.r===7)) {
                    // Instead of Queen, explode row
                    const targetRow = to.r;
                    for(let c=0; c<8; c++) {
                        if (newBoard[targetRow][c] && newBoard[targetRow][c][1] !== 'K') {
                            newBoard[targetRow][c] = null;
                            exploded.push({r:targetRow, c});
                        }
                    }
                    newBoard[to.r][to.c] = null; // Goblin dies too
                    exploded.push(to);
                    return { board: newBoard, exploded, captured: true, msg: "GOBLIN SABOTAGE!" };
                }

                // 5. VAMPIRE QUEEN
                if (p && p[1] === 'Q' && t) {
                    // Resurrect Pawn
                    const spawnRow = p[0] === 'w' ? 6 : 1;
                    // Find empty spot
                    for(let c=0; c<8; c++) {
                        if(!newBoard[spawnRow][c]) {
                            newBoard[spawnRow][c] = p[0]+'P';
                            break;
                        }
                    }
                }

                // 6. ATOMIC EXPLOSION
                if (t) { 
                    for(let i=to.r-1; i<=to.r+1; i++) {
                        for(let j=to.c-1; j<=to.c+1; j++) {
                            if(nr(i,j)) {
                                if (i === to.r && j === to.c) continue; // Survivor
                                const victim = newBoard[i][j];
                                if (victim && victim[1] !== 'K') {
                                    newBoard[i][j] = null;
                                }
                                exploded.push({r:i, c:j});
                            }
                        }
                    }
                }
                
                return { board: newBoard, exploded, captured: !!t, msg };
            },

            getLegalMoves(r, c, currentBoard = this.board) {
                const p = currentBoard[r][c];
                if(!p) return [];
                const pseudo = this.getPseudoMoves(r, c, currentBoard);
                const myColor = p[0];

                return pseudo.filter(move => {
                    const res = this.applyMove(currentBoard, {r,c}, move);
                    const enemyColor = myColor==='w'?'b':'w';
                    if (!this.findKing(res.board, enemyColor)) return true;
                    if (!this.findKing(res.board, myColor)) return false;
                    return true;
                });
            },

            getPseudoMoves(r, c, boardState) {
                const p = boardState[r][c];
                if (!p) return [];
                const color = p[0];
                const type = p[1];
                const moves = [];

                const add = (nr, nc) => {
                    if (nr>=0 && nr<8 && nc>=0 && nc<8) {
                        const target = boardState[nr][nc];
                        
                        // BRIDGE RULE Check
                        const isBridge = (nr===3||nr===4) && (nc===3||nc===4);
                        if (isBridge && this.isBridgeOccupied(boardState, r, c)) return false;

                        if (target === null) {
                            moves.push({r:nr, c:nc});
                            return true;
                        } else if (target[0] !== color) {
                            moves.push({r:nr, c:nc});
                            return false;
                        }
                    }
                    return false;
                };

                const dirs = {
                    R: [[0,1],[0,-1],[1,0],[-1,0]],
                    B: [[1,1],[1,-1],[-1,1],[-1,-1]],
                    N: [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]],
                    K: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
                };
                dirs.Q = [...dirs.R, ...dirs.B];

                if (type === 'P') {
                    const d = color === 'w' ? -1 : 1;
                    // Normal
                    if (nr(r+d, c) && boardState[r+d][c] === null) {
                        // Bridge Check for Pawn
                        const isBridge = (r+d===3||r+d===4) && (c===3||c===4);
                        if (!isBridge || !this.isBridgeOccupied(boardState, r, c)) {
                            moves.push({r:r+d, c});
                            if ((color==='w'&&r===6 || color==='b'&&r===1) && boardState[r+d*2][c] === null) {
                                // Bridge check double jump
                                const isBridge2 = (r+d*2===3||r+d*2===4) && (c===3||c===4);
                                if (!isBridge2 || !this.isBridgeOccupied(boardState, r, c)) {
                                    moves.push({r:r+d*2, c});
                                }
                            }
                        }
                    }
                    // QUANTUM BACKWARDS
                    if (nr(r-d, c) && boardState[r-d][c] === null) {
                         const isBridge = (r-d===3||r-d===4) && (c===3||c===4);
                         if (!isBridge || !this.isBridgeOccupied(boardState, r, c)) {
                             moves.push({r:r-d, c});
                         }
                    }

                    // Capture
                    [[d,1],[d,-1]].forEach(([dr,dc]) => {
                        if (nr(r+dr, c+dc)) {
                            const t = boardState[r+dr][c+dc];
                            const isBridge = (r+dr===3||r+dr===4) && (c+dc===3||c+dc===4);
                            if ((!isBridge || !this.isBridgeOccupied(boardState,r,c)) && t && t[0]!==color) 
                                moves.push({r:r+dr, c:c+dc});
                        }
                    });
                } else if (['R','B','Q'].includes(type)) {
                    dirs[type].forEach(([dr, dc]) => {
                        let nr = r+dr, nc = c+dc;
                        while(add(nr, nc)) { nr+=dr; nc+=dc; }
                    });
                } else {
                    dirs[type].forEach(([dr, dc]) => add(r+dr, c+dc));
                }
                return moves;
            },

            findKing(board, color) {
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    if(board[r][c] === color+'K') return {r,c};
                }
                return null;
            },

            applyGravity() {
                // Shift all pieces down 1 row
                // To avoid overwriting, process from bottom to top
                // Row 7 is destroyed
                const newBoard = Array(8).fill(null).map(()=>Array(8).fill(null));
                for(let r=6; r>=0; r--) {
                    for(let c=0; c<8; c++) {
                        if(this.board[r][c]) {
                            // If r+1 is empty, move there. If occupied, SQUISH (Both die? or stack? Let's say destroy bottom one)
                            // "Gravity slides pieces down".
                            // If target is occupied, the falling piece crushes it (unless King).
                            const target = newBoard[r+1][c];
                            if (!target || target[1]!=='K') {
                                newBoard[r+1][c] = this.board[r][c];
                            } else {
                                // King blocks gravity? Or King dies? Let's make King block.
                                newBoard[r][c] = this.board[r][c];
                            }
                        }
                    }
                }
                // Kings at row 7 stay? Or die?
                for(let c=0; c<8; c++) {
                    if (this.board[7][c] && this.board[7][c][1]==='K') newBoard[7][c] = this.board[7][c]; 
                }
                this.board = newBoard;
            },

            checkState() {
                const wKing = this.findKing(this.board, 'w');
                const bKing = this.findKing(this.board, 'b');
                if (!wKing) return 'b'; 
                if (!bKing) return 'w'; 
                return null;
            }
        };

        const Game = {
            selected: null, validMoves: [], history: [],
            mode: 'local', myColor: 'w', gameId: null, user: null, isOver: false,

            init() {
                Engine.init();
                this.setupGrid();
                try {
                    firebase.initializeApp(firebaseConfig);
                    this.db = firebase.firestore();
                    firebase.auth().onAuthStateChanged(u => {
                        this.user = u;
                        if(!u) firebase.auth().signInAnonymously();
                    });
                } catch(e) {}
                this.render();
            },

            setupGrid() {
                const g = document.getElementById('board-grid');
                g.innerHTML = '';
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    const d = document.createElement('div');
                    d.className = `square ${(r+c)%2===0?'light':'dark'}`;
                    // Bridge Highlight
                    if ((r===3||r===4)&&(c===3||c===4)) d.classList.add('bridge-zone');
                    
                    d.dataset.r = r; d.dataset.c = c;
                    d.onclick = () => this.handleClick(r, c);
                    g.appendChild(d);
                }
            },

            handleClick(r, c) {
                if (this.isOver) return;
                if (this.mode === 'online' && Engine.turn !== this.myColor) return;

                if (this.selected) {
                    const move = this.validMoves.find(m => m.r === r && m.c === c);
                    if (move) {
                        this.executeMove(this.selected, move);
                        this.clearSelection();
                        return;
                    }
                }

                const p = Engine.board[r][c];
                if (p && p[0] === Engine.turn) {
                    this.selected = {r, c};
                    this.validMoves = Engine.getLegalMoves(r, c);
                    this.highlightMoves();
                } else {
                    this.clearSelection();
                }
            },

            highlightMoves() {
                this.clearHighlights();
                const g = document.getElementById('board-grid').children;
                const selIdx = this.selected.r*8 + this.selected.c;
                g[selIdx].classList.add('selected-sq');

                this.validMoves.forEach(m => {
                    const idx = m.r*8 + m.c;
                    if (Engine.board[m.r][m.c]) g[idx].classList.add('capture-move');
                    else g[idx].classList.add('valid-move');
                });
            },

            clearHighlights() {
                document.querySelectorAll('.square').forEach(el => 
                    el.className = el.className.replace(/ selected-sq| valid-move| capture-move/g, '')
                );
            },

            clearSelection() {
                this.selected = null;
                this.validMoves = [];
                this.clearHighlights();
            },

            executeMove(from, to, isRemote = false) {
                if(!isRemote) this.history.push({b: JSON.stringify(Engine.board), t: Engine.turn});

                const res = Engine.applyMove(Engine.board, from, to);
                Engine.board = res.board;

                if(res.exploded.length > 0) this.showExplosion(res.exploded);
                if(res.msg && !isRemote) UI.showToast(res.msg);

                Engine.turnCount++;
                // GRAVITY EVERY 5 TURNS
                if (Engine.turnCount % 10 === 0 && Engine.turnCount > 0) { // 5 full rounds = 10 moves
                    Engine.applyGravity();
                    UI.showToast("‚ö†Ô∏è GRAVITY SHIFT! ‚ö†Ô∏è");
                }

                const winner = Engine.checkState();
                if (winner) {
                    this.handleWin(winner);
                    if(this.mode === 'online' && !isRemote) {
                        this.db.collection('atomic_games').doc(this.gameId).update({
                            board: JSON.stringify(Engine.board),
                            winner: winner
                        });
                    }
                    return;
                }

                const nextTurn = Engine.turn === 'w' ? 'b' : 'w';
                Engine.turn = nextTurn;

                if(this.mode === 'online' && !isRemote) {
                    this.db.collection('atomic_games').doc(this.gameId).update({
                        board: JSON.stringify(Engine.board),
                        turn: nextTurn,
                        lastMove: {from, to, exploded: res.exploded},
                        mines: JSON.stringify(Engine.mines), // Sync mines state just in case
                        turnCount: Engine.turnCount
                    });
                } else {
                    this.render();
                    if(this.mode === 'bot' && nextTurn === 'b') setTimeout(() => this.botThink(), 500);
                }
                this.render();
            },

            handleWin(winner) {
                this.isOver = true;
                this.render();
                const text = winner === 'w' ? "WHITE WINS!" : "BLACK WINS!";
                const color = winner === 'w' ? "#fff" : "var(--accent)";
                document.getElementById('win-text').innerText = text;
                document.getElementById('win-text').style.color = color;
                document.getElementById('win-modal').classList.remove('hidden');
            },

            botThink() {
                const moves = [];
                for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                    if(Engine.board[r][c]?.startsWith('b')) {
                        Engine.getLegalMoves(r, c).forEach(to => moves.push({from:{r,c}, to}));
                    }
                }
                if(moves.length === 0) return; 
                let bestMove = moves[0];
                let bestScore = -Infinity;
                for (let m of moves) {
                    const score = Math.random(); // Dumb bot for chaos
                    if (score > bestScore) { bestScore = score; bestMove = m; }
                }
                this.executeMove(bestMove.from, bestMove.to);
            },

            render() {
                const layer = document.getElementById('pieces');
                layer.innerHTML = '';
                const sym = {w:{K:'‚ôî',Q:'‚ôï',R:'‚ôñ',B:'‚ôó',N:'‚ôò',P:'‚ôô'}, b:{K:'‚ôö',Q:'‚ôï',R:'‚ôú',B:'‚ôù',N:'‚ôû',P:'‚ôü'}};
                const rot = (this.mode==='online' && this.myColor==='b');
                
                document.getElementById('board-wrapper').style.transform = rot ? 'rotate(180deg)' : '';
                document.getElementById('board-wrapper').style.setProperty('--rot', rot ? '180deg' : '0deg');

                Engine.board.forEach((row, r) => row.forEach((c, col) => {
                    if(!c) return;
                    const el = document.createElement('div');
                    el.className = `piece p-${c[0]}`;
                    el.textContent = sym[c[0]][c[1]];
                    el.style.transform = `translate(${col*100}%, ${r*100}%) ${rot?'rotate(180deg)':''}`;
                    layer.appendChild(el);
                }));

                const txt = this.mode==='online' 
                    ? (Engine.turn===this.myColor ? "YOUR TURN" : "OPPONENT") 
                    : (Engine.turn==='w' ? "White Turn" : "Black Turn");
                document.getElementById('status').textContent = txt;
            },

            showExplosion(coords) {
                const layer = document.getElementById('effects');
                const wrap = document.getElementById('board-wrapper');
                wrap.classList.remove('shake');
                void wrap.offsetWidth;
                wrap.classList.add('shake');
                coords.forEach(p => {
                    const el = document.createElement('div');
                    el.className = 'explosion';
                    el.style.left = (p.c * 12.5) + '%';
                    el.style.top = (p.r * 12.5) + '%';
                    layer.appendChild(el);
                    setTimeout(() => el.remove(), 600);
                });
            },

            async findMatch() {
                document.getElementById('loading').classList.remove('hidden');
                this.mode = 'online';
                const ref = this.db.collection('atomic_games');
                const snap = await ref.where('status', '==', 'waiting').limit(1).get();
                if(!snap.empty) {
                    const doc = snap.docs[0];
                    await doc.ref.update({ status: 'playing', playerBlack: this.user.uid });
                    this.startGame(doc.id, 'b');
                } else {
                    const doc = await ref.add({ 
                        status: 'waiting', 
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(), 
                        playerWhite: this.user.uid, 
                        board: JSON.stringify(Engine.board), 
                        mines: JSON.stringify(Engine.mines), // Sync Mines
                        turnCount: 0,
                        turn: 'w' 
                    });
                    this.startGame(doc.id, 'w');
                }
            },
            startGame(id, color) {
                this.gameId = id; this.myColor = color;
                this.unsub = this.db.collection('atomic_games').doc(id).onSnapshot(doc => {
                    const d = doc.data();
                    if(!d || d.status !== 'playing') return;
                    document.getElementById('menu').classList.add('hidden');
                    document.getElementById('loading').classList.add('hidden');
                    
                    if (d.winner) {
                        this.handleWin(d.winner);
                        return;
                    }

                    if(d.board !== JSON.stringify(Engine.board)) {
                        Engine.board = JSON.parse(d.board);
                        Engine.turn = d.turn;
                        if(d.mines) Engine.mines = JSON.parse(d.mines);
                        if(d.turnCount) Engine.turnCount = d.turnCount;
                        
                        if(d.lastMove?.exploded?.length && Engine.turn === this.myColor) this.showExplosion(d.lastMove.exploded);
                        this.render();
                    }
                });
            },
            cancelMatch() {
                if(this.unsub) this.unsub();
                if(this.gameId && this.myColor==='w') this.db.collection('atomic_games').doc(this.gameId).delete();
                document.getElementById('loading').classList.add('hidden');
            },
            startLocal() { this.mode='local'; document.getElementById('menu').classList.add('hidden'); Engine.init(); this.render(); },
            startBot() { this.mode='bot'; document.getElementById('menu').classList.add('hidden'); Engine.init(); this.render(); },
            undo() {
                if(this.mode === 'online') return;
                if(this.history.length) {
                    const state = this.history.pop();
                    Engine.board = JSON.parse(state.b);
                    Engine.turn = state.t;
                    this.isOver = false;
                    document.getElementById('win-modal').classList.add('hidden');
                    this.render();
                    this.clearSelection();
                }
            }
        };

        Game.init();
    </script>
</body>
</html>
